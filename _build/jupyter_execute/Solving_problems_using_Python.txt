!pip install gurobipy

# Import gurobi library
from gurobipy import * # This command imports the Gurobi functions and classes.

# Create new model
m = Model('Factory') # The Model() constructor creates a model object m. The name of this new model is 'Factory'.
                     # This new model m initially contains no decision variables, constraints, or objective function.

# Create decision variables
# This method adds a decision variable to the model object m, one by one; i.e. x1 and then x2. 
# The argument of the method gives the name of added decision variable. 
# The default values are applied here; i.e. the decision variables are of type continuous and non-negative, with no upper bound.
x1 = m.addVar(lb=0, vtype = GRB.CONTINUOUS, name='chairs') 
x2 = m.addVar(lb=0, vtype = GRB.CONTINUOUS, name='tables')

#Define objective function
#This method adds the objective function to the model object m. The first
#argument is a linear expression (LinExpr) and the second argument defines
#the sense of the optimization.
m.setObjective(40*x1+50*x2, GRB.MAXIMIZE)

#Add constraints
#This method adds a constraint to the model object m and considers a linear of coefficient-variables elements
m.addConstr(1*x1+2*x2<=40, name='wood')
m.addConstr(4*x1+3*x2<=120, name= 'labor')

#Run optimization engine
#This method runs the optimization engine to solve the LP problem in the model object m
m.optimize()

#display optimal production plan
for v in m.getVars():
  print(v.varName, v.x)
print('optimal total revenue:', m.objVal)

#Python list comprehension
#List comprehension is compact way to create lists
sqrd = [i*i for i in range(5)]
print(sqrd) 

#Can be used to create subsequences that satisfy certain conditions (ex: filtering a list)
bigsqrd = [i*i for i in range(5) if i*i >= 5]
print(bigsqrd) 

#Can be used with multiple for loops (ex: all combinations)
prod = [i*j for i in range(3) for j in range(4)]
print(prod) 

#Generator expression is similar, but no brackets (ex: argument to aggregate sum)
sumsqrd = sum(i*i for i in range(5))
print(sumsqrd)

from gurobipy import * 

#resource data
#The multidict function returns a list which maps each resource (key) to its capacity value.
resources, capacity = multidict({ 
    'wood':  40,
    'labor': 120 })
print(resources, capacity)

#products data
#This multidict function returns a list which maps each product (key) to its price value.
products, price = multidict({
    'chair': 40,
    'table': 50 })
print(products, price)

#bill of materials: resources required by each product
#This dictionary has a 2-tuple as a key, mapping the resource required by a product with its quantity per.
bom={
('wood','chair'):1,
('wood','table'):2,
('labor','chair'):4,
('labor','table'):3
}
print(bom)

m = Model('Factory')

#This method adds decision variables to the model object m
make = m.addVars(products, name='make')

#This method adds constraints to the model object m
res = m.addConstrs(((sum(bom[r,p]*make[p] for p in products) <= capacity[r]) for r in resources),name='R')

#This method adds the objective function to the model object m.
#The first argument is a linear expression which is generated by the 'prod' method. 
#The 'prod' method is the product of the object (revenue) with the object (make) 
#for each product p in the set (products). The second argument defines the sense of the optimization.
m.setObjective(make.prod(price), GRB.MAXIMIZE)

#save model for inspection
m.write('factory.lp')

cat factory.lp

# run optimization engine
m.optimize()

#display optimal production plan
for v in m.getVars():
  print(v.varName, v.x)
print('optimal total revenue:', m.objVal)

for v in m.getVars():
  print(v.varName, v.x)
print('optimal total revenue:', m.objVal)

for var in m.getVars(): # descision variable
    print(var.varName, '=', var.x, (var.obj,var.SAObjLow, var.SAObjUp, var.RC))

for con in m.getConstrs(): # constraints
    print(con.ConstrName, ': slack =', con.slack,', shadow price=',
          con.pi,',', (con.RHS, con.SARHSLow, con.SARHSUp))
    
print("objective value =", m.objVal)

# Adding new variable

products, price = multidict({
    'chair': 40,
    'table': 50,
    'bench' : 30})
bom={
('wood','chair'):1,
('wood','table'):2,
('wood','bench'):1.2,
('labor','chair'):4,
('labor','table'):3,
('labor','bench'):2,
}

m = Model('Factory')

make = m.addVars(products,name='make')
res = m.addConstrs(((sum(bom[r,p]*make[p] for p in products) <= capacity[r]) for r in resources),name='R')
m.setObjective(make.prod(price), GRB.MAXIMIZE)
m.write('factory.lp')

cat factory.lp

m.optimize()

#display optimal production plan
for v in m.getVars():
  print(v.varName, v.x)
print('optimal total revenue:', m.objVal)

for var in m.getVars(): # descision variable
    print(var.varName, '=', var.x, (var.obj,var.SAObjLow, var.SAObjUp, var.RC))

for con in m.getConstrs(): # constraints
    print(con.ConstrName, ': slack =', con.slack,', shadow price=',
          con.pi,',', (con.RHS, con.SARHSLow, con.SARHSUp))
    
print("objective value =", m.objVal)

# Adding new constraint

resources, capacity = multidict({ 
    'wood':  40,
    'labor': 120,
    'packaging': 5 })


products, price = multidict({
    'chair': 40,
    'table': 50})
bom={
('wood','chair'):1,
('wood','table'):2,
('labor','chair'):4,
('labor','table'):3,
('packaging','chair'):0.2,
('packaging','table'):0.1,
}

m = Model('Factory')

make = m.addVars(products,name='make')
res = m.addConstrs(((sum(bom[r,p]*make[p] for p in products) <= capacity[r]) for r in resources),name='R')
m.setObjective(make.prod(price), GRB.MAXIMIZE)
m.write('factory.lp')

cat factory.lp

m.optimize()

#display optimal production plan
for v in m.getVars():
  print(v.varName, v.x)
print('optimal total revenue:', m.objVal)

for var in m.getVars(): # descision variable
    print(var.varName, '=', var.x, (var.obj,var.SAObjLow, var.SAObjUp, var.RC))

for con in m.getConstrs(): # constraints
    print(con.ConstrName, ': slack =', con.slack,', shadow price=',
          con.pi,',', (con.RHS, con.SARHSLow, con.SARHSUp))
    
print("objective value =", m.objVal)

c = [10, 6]    
A = [[3,   8 ],
     [45, 30 ]]
b = [20, 180]

import numpy as np
print(np.array(c).shape,np.array(A).shape,np.array(b).shape)
decision_variables = range(len(c))     
constraints = range(np.array(A).shape[0])

m = Model("C2Q1")

x = []
for i in decision_variables:
    x.append(m.addVar(lb = 0, vtype = GRB.CONTINUOUS, name = 'x' + str(i)))

m.setObjective(quicksum(c[i] * x[i] for i in decision_variables) , GRB.MAXIMIZE) 

m.addConstrs((quicksum(A[j][i] * x[i] for i in decision_variables) 
                           <= b[j] for j in constraints), "constraints")

m.optimize()

for var in m.getVars(): # descision variable
    print(var.varName, '=', var.x, (var.obj,var.SAObjLow, var.SAObjUp, var.RC))

for con in m.getConstrs(): # constraints
    print(con.ConstrName, ': slack =', con.slack,', shadow price=',
          con.pi,',', (con.RHS, con.SARHSLow, con.SARHSUp))
    
print("objective value =", m.objVal)

c = [0.5, 0.03]    
A = [[8,6 ],
     [1,2 ]]
b = [48,12]
print(np.array(c).shape,np.array(A).shape,np.array(b).shape)
decision_variables = range(len(c))     
constraints = range(np.array(A).shape[0])

m = Model("C2Q1")

x = []
for i in decision_variables:
    x.append(m.addVar(lb = 0, vtype = GRB.CONTINUOUS, name = 'x' + str(i)))

m.setObjective(quicksum(c[i] * x[i] for i in decision_variables) , GRB.MINIMIZE) 

m.addConstrs((quicksum(A[j][i] * x[i] for i in decision_variables) 
                           >= b[j] for j in constraints), "constraints")

m.optimize()

for var in m.getVars(): # descision variable
    print(var.varName, '=', var.x, (var.obj,var.SAObjLow, var.SAObjUp, var.RC))

for con in m.getConstrs(): # constraints
    print(con.ConstrName, ': slack =', con.slack,', shadow price=',
          con.pi,',', (con.RHS, con.SARHSLow, con.SARHSUp))
    
print("objective value =", m.objVal)

c = [4,3,2]    
A = [[2,4,1 ],
     [3,2,1 ]]
b = [16,12]
print(np.array(c).shape,np.array(A).shape,np.array(b).shape)
decision_variables = range(len(c))     
constraints = range(np.array(A).shape[0])

m = Model("C4Q8")

x = []
for i in decision_variables:
    x.append(m.addVar(lb = 0, vtype = GRB.CONTINUOUS, name = 'x' + str(i)))

m.setObjective(quicksum(c[i] * x[i] for i in decision_variables) , GRB.MINIMIZE) 

m.addConstrs((quicksum(A[j][i] * x[i] for i in decision_variables) 
                           >= b[j] for j in constraints), "constraints")

m.optimize()

for var in m.getVars(): # descision variable
    print(var.varName, '=', var.x, (var.obj,var.SAObjLow, var.SAObjUp, var.RC))

for con in m.getConstrs(): # constraints
    print(con.ConstrName, ': slack =', con.slack,', shadow price=',
          con.pi,',', (con.RHS, con.SARHSLow, con.SARHSUp))
    
print("objective value =", m.objVal)

c = [22,18,35,41,30,28,25,36,18]    
A = [[1,1,1,0,0,0,0,0,0 ],
     [0,0,0,1,1,1,0,0,0 ],
     [0,0,0,0,0,0,1,1,1 ],
     [1,0,0,1,0,0,1,0,0 ],
     [0,1,0,0,1,0,0,1,0 ],
     [0,0,1,0,0,1,0,0,1 ]]
b = [1,1,1,1,1,1]
print(np.array(c).shape,np.array(A).shape,np.array(b).shape)
decision_variables = range(len(c))     
constraints = range(np.array(A).shape[0])

m = Model("C4Q32")

x = []
for i in decision_variables:
    x.append(m.addVar(lb = 0, vtype = GRB.CONTINUOUS, name = 'x' + str(i)))

m.setObjective(quicksum(c[i] * x[i] for i in decision_variables) , GRB.MINIMIZE) 

m.addConstrs((quicksum(A[j][i] * x[i] for i in decision_variables) 
                           == b[j] for j in constraints), "constraints")

m.optimize()

for var in m.getVars(): # descision variable
    print(var.varName, '=', var.x, (var.obj,var.SAObjLow, var.SAObjUp, var.RC))

for con in m.getConstrs(): # constraints
    print(con.ConstrName, ': slack =', con.slack,', shadow price=',
          con.pi,',', (con.RHS, con.SARHSLow, con.SARHSUp))
    
print("objective value =", m.objVal)

c = [22,18,35,41,30,28,25,36,18,20,20,20]    
A = [[1,1,1,0,0,0,0,0,0,0,0,0 ],
     [0,0,0,1,1,1,0,0,0,0,0,0 ],
     [0,0,0,0,0,0,1,1,1,0,0,0 ],
     [0,0,0,0,0,0,0,0,0,1,1,1 ],
     [1,0,0,1,0,0,1,0,0,1,0,0 ],
     [0,1,0,0,1,0,0,1,0,0,1,0 ],
     [0,0,1,0,0,1,0,0,1,0,0,1 ]]
b =  [1,1,1,1,1,1,1]
print(np.array(c).shape,np.array(A).shape,np.array(b).shape)
decision_variables = range(len(c))     
constraints = range(np.array(A).shape[0])

m = Model("C4Q32")

x = []
for i in decision_variables:
    x.append(m.addVar(lb = 0, vtype = GRB.CONTINUOUS, name = 'x' + str(i)))

m.setObjective(quicksum(c[i] * x[i] for i in decision_variables) , GRB.MINIMIZE) 

m.addConstrs((quicksum(A[j][i] * x[i] for i in decision_variables) 
                           <= b[j] for j in range(4)), "constraints")

m.addConstrs((quicksum(A[j][i] * x[i] for i in decision_variables) 
                           == b[j] for j in range(4,7)), "constraints")
m.optimize()

for var in m.getVars(): # descision variable
    print(var.varName, '=', var.x, (var.obj,var.SAObjLow, var.SAObjUp, var.RC))

for con in m.getConstrs(): # constraints
    print(con.ConstrName, ': slack =', con.slack,', shadow price=',
          con.pi,',', (con.RHS, con.SARHSLow, con.SARHSUp))
    
print("objective value =", m.objVal)

c = [40,65,70,30]    
A = [[1,1,0,0 ],
     [0,0,1,1 ],
     [1,0,1,0 ],
     [0,1,0,1 ]]
b =  [250, 400, 300, 350]
print(np.array(c).shape,np.array(A).shape,np.array(b).shape)
decision_variables = range(len(c))     
constraints = range(np.array(A).shape[0])

m = Model("C4Q33")

x = []
for i in decision_variables:
    x.append(m.addVar(lb = 0, vtype = GRB.CONTINUOUS, name = 'x' + str(i)))

m.setObjective(quicksum(c[i] * x[i] for i in decision_variables) , GRB.MINIMIZE) 
m.addConstrs((quicksum(A[j][i] * x[i] for i in decision_variables) 
                           == b[j] for j in constraints), "constraints")
m.optimize()

for var in m.getVars(): # descision variable
    print(var.varName, '=', var.x, (var.obj,var.SAObjLow, var.SAObjUp, var.RC))

for con in m.getConstrs(): # constraints
    print(con.ConstrName, ': slack =', con.slack,', shadow price=',
          con.pi,',', (con.RHS, con.SARHSLow, con.SARHSUp))
    
print("objective value =", m.objVal)
